import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import subprocess
import os
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np
import time
import platform 

class HeatEquationApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Heat Equation Solver Demo")
        self.root.geometry("900x700")
        
        # Create main frames
        self.control_frame = ttk.Frame(root, padding="10")
        self.control_frame.pack(fill=tk.X)
        
        self.output_frame = ttk.Frame(root, padding="10")
        self.output_frame.pack(fill=tk.BOTH, expand=True)
        
        self.plot_frame = ttk.Frame(root, padding="10")
        self.plot_frame.pack(fill=tk.BOTH, expand=True)
        
        # Control widgets
        ttk.Label(self.control_frame, text="Implementation:").grid(row=0, column=0, padx=5)
        
        self.impl_var = tk.StringVar()
        self.impl_combobox = ttk.Combobox(
            self.control_frame, 
            textvariable=self.impl_var,
            values=["Serial", "OpenMP", "CUDA", "Hybrid"]
        )
        self.impl_combobox.grid(row=0, column=1, padx=5)
        self.impl_combobox.current(0)
        
        ttk.Label(self.control_frame, text="Grid Size (Nx, Ny):").grid(row=0, column=2, padx=5)
        
        self.grid_var = tk.StringVar()
        self.grid_combobox = ttk.Combobox(
            self.control_frame, 
            textvariable=self.grid_var,
            values=["100x100", "200x200", "300x300", "500x500"]
        )
        self.grid_combobox.grid(row=0, column=3, padx=5)
        self.grid_combobox.current(1)
        
        ttk.Label(self.control_frame, text="Time Steps:").grid(row=0, column=4, padx=5)
        
        self.steps_var = tk.StringVar(value="1000")
        self.steps_entry = ttk.Entry(self.control_frame, textvariable=self.steps_var, width=8)
        self.steps_entry.grid(row=0, column=5, padx=5)
        
        self.run_button = ttk.Button(self.control_frame, text="Run", command=self.run_solver)
        self.run_button.grid(row=0, column=6, padx=10)
        
        # Output widgets
        self.output_text = scrolledtext.ScrolledText(
            self.output_frame,
            wrap=tk.WORD,
            width=100,
            height=10
        )
        self.output_text.pack(fill=tk.BOTH, expand=True)
        
        # Plot area
        self.figure = plt.Figure(figsize=(6, 4), dpi=100)
        self.ax = self.figure.add_subplot(111)
        self.canvas = FigureCanvasTkAgg(self.figure, self.plot_frame)
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
        
        # Initialize variables
        self.last_result = None
        self.grid_size = 200
        
    def run_solver(self):
        implementation = self.impl_var.get()
        grid_size = int(self.grid_var.get().split('x')[0])
        time_steps = self.steps_var.get()
        
        self.output_text.insert(tk.END, f"\nRunning {implementation} solver with grid {grid_size}x{grid_size}, {time_steps} steps...\n")
        self.output_text.see(tk.END)
        self.root.update()
            
        try:
            # Determine which executable to run
            if platform.system() == "Linux":
                # For WSL/Linux, use ./ prefix
                if implementation == "Serial":
                    cmd = f"./serial_heat {grid_size} {grid_size} {time_steps}"
                elif implementation == "OpenMP":
                    cmd = f"./omp_heat {grid_size} {grid_size} {time_steps}"
                elif implementation == "CUDA":
                    cmd = f"./cuda_heat {grid_size} {grid_size} {time_steps}"
                elif implementation == "Hybrid":
                    cmd = f"./hybrid_heat {grid_size} {grid_size} {time_steps}"
            else:
                # For Windows (without ./)
                if implementation == "Serial":
                    cmd = f"serial_heat {grid_size} {grid_size} {time_steps}"
                elif implementation == "OpenMP":
                    cmd = f"omp_heat {grid_size} {grid_size} {time_steps}"
                elif implementation == "CUDA":
                    cmd = f"cuda_heat {grid_size} {grid_size} {time_steps}"
                elif implementation == "Hybrid":
                    cmd = f"hybrid_heat {grid_size} {grid_size} {time_steps}"
            
            # Run the command and capture output
            result = subprocess.run(cmd, shell=True, check=True, 
                                  stdout=subprocess.PIPE, stderr=subprocess.PIPE,
                                  text=True)
            
            # Display output
            self.output_text.insert(tk.END, result.stdout)
            if result.stderr:
                self.output_text.insert(tk.END, f"\nErrors:\n{result.stderr}")
            
            # Parse and visualize results
            self.parse_and_visualize(result.stdout, grid_size)
            
        except subprocess.CalledProcessError as e:
            self.output_text.insert(tk.END, f"\nError running solver:\n{e.stderr}")
        except Exception as e:
            self.output_text.insert(tk.END, f"\nError: {str(e)}")
        
        self.output_text.see(tk.END)

    def parse_and_visualize(self, output, grid_size):
        # Parse the output to get all metrics
        lines = output.split('\n')
        metrics = {
            "Implementation": "Unknown",
            "Threads": "N/A",
            "GridSize": f"{grid_size}x{grid_size}",
            "TimeSteps": "N/A",
            "Time": "N/A",
            "Throughput": "N/A",
            "CenterValue": "N/A"
        }
        
        for line in lines:
            if "Implementation:" in line:
                metrics["Implementation"] = line.split(":")[1].strip()
            elif "Threads:" in line:
                metrics["Threads"] = line.split(":")[1].strip()
            elif "GridSize:" in line:
                metrics["GridSize"] = line.split(":")[1].strip()
            elif "TimeSteps:" in line:
                metrics["TimeSteps"] = line.split(":")[1].strip()
            elif "Time:" in line:
                metrics["Time"] = line.split(":")[1].strip()
            elif "Throughput:" in line:
                metrics["Throughput"] = line.split(":")[1].strip()
            elif "CenterValue:" in line:
                metrics["CenterValue"] = line.split(":")[1].strip()
        
        # Update the plot
        self.ax.clear()
        
        # Create sample heat distribution
        x = np.linspace(-0.5, 0.5, grid_size)
        y = np.linspace(-0.5, 0.5, grid_size)
        X, Y = np.meshgrid(x, y)
        Z = np.exp(-50*(X**2 + Y**2))
        
        # Plot
        c = self.ax.pcolormesh(X, Y, Z, cmap='hot', shading='auto')
        self.figure.colorbar(c, ax=self.ax)
        self.ax.set_title(f"{metrics['Implementation']} - Heat Distribution\nCenter: {metrics['CenterValue']}")
        self.ax.set_xlabel('X')
        self.ax.set_ylabel('Y')
        
        self.canvas.draw()
        
        # Store the last result
        self.last_result = metrics
        
        # Update output with parsed metrics
        self.output_text.insert(tk.END, "\nParsed Results:\n")
        for key, value in metrics.items():
            self.output_text.insert(tk.END, f"{key:12}: {value}\n")
    
    # def parse_and_visualize(self, output, grid_size):
    #     # Parse the output to get the center value and performance metrics
    #     lines = output.split('\n')
    #     metrics = {
    #         "Time": None,
    #         "Throughput": None,
    #         "u_center": None
    #     }
        
    #     for line in lines:
    #         if "Time" in line:
    #             metrics["Time"] = line.split(":")[1].strip()
    #         elif "Throughput" in line:
    #             metrics["Throughput"] = line.split(":")[1].strip()
    #         elif "u_center" in line:
    #             metrics["u_center"] = line.split(":")[1].strip()
        
    #     # Update the plot with a sample heat distribution
    #     self.ax.clear()
        
    #     # Create a sample heat distribution (in a real app, you'd load the actual data)
    #     x = np.linspace(-0.5, 0.5, grid_size)
    #     y = np.linspace(-0.5, 0.5, grid_size)
    #     X, Y = np.meshgrid(x, y)
        
    #     # Simulate a heat distribution (this is just for visualization)
    #     Z = np.exp(-50*(X**2 + Y**2))
        
    #     # Plot the heat distribution
    #     c = self.ax.pcolormesh(X, Y, Z, cmap='hot', shading='auto')
    #     self.figure.colorbar(c, ax=self.ax)
    #     self.ax.set_title(f"Heat Distribution (Center: {metrics['u_center']})")
    #     self.ax.set_xlabel('X')
    #     self.ax.set_ylabel('Y')
        
    #     self.canvas.draw()
        
    #     # Store the last result
    #     self.last_result = metrics

def main():
    root = tk.Tk()
    app = HeatEquationApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()